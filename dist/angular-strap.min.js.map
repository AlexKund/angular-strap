{"version":3,"sources":["angular-strap.js","affix/affix.js","alert/alert.js","aside/aside.js","button/button.js","collapse/collapse.js","datepicker/datepicker.js","dropdown/dropdown.js","helpers/date-formatter.js","helpers/date-parser.js","helpers/debounce.js","helpers/dimensions.js","helpers/parse-options.js","helpers/raf.js","modal/modal.js","navbar/navbar.js","popover/popover.js","scrollspy/scrollspy.js","select/select.js","tab/tab.js","timepicker/timepicker.js","tooltip/tooltip.js","typeahead/typeahead.js"],"names":["window","document","undefined","angular","bodyEl","$window","body","windowEl","defaults","AffixFactory","offsetTop","$affix","inlineStyles","options","this","$get","reset","setWidth","initialAffixTop","offsetParent","match","getRequiredAffixClass","unpin","position","top","scrollTop","getScrollTop","scrollHeight","getScrollHeight","targetEl","pageYOffset","directive","parent","target","initialOffsetTop","offsetBottom","affixed","element","init","i","$parseOffsets","on","checkPosition","require","checkPositionWithEventLoop","dimensions","offset","destroy","style","width","off","affix","setTimeout","elementHeight","height","css","addClass","offsetUnpin","offsetHeight","offsetWidth","$debouncedOnResize","$onResize","initialPosition","restrict","affixTarget","$element","forEach","link","key","scope","option","$on","attr","test","controller","animation","prefixClass","container","provider","backdrop","keyboard","show","duration","type","dismissable","AlertFactory","$alert","$scope","config","extend","$timeout","hide","isDefined","title","newValue","oldValue","trustAsHtml","hasOwnProperty","bsAlert","$observe","content","alert","trigger","toggle","module","contentTemplate","html","AsideFactory","$aside","requestAnimationFrame","$modal","bsAside","$watch","aside","activeClass","compile","children","querySelectorAll","childEl","ngModel","removeAttr","child","$button","constantValueRegExp","isInput","trueValue","falseValue","hasExoticValues","viewValue","$formatters","push","$render","modelValue","isActive","equals","checked","activeElement","bind","toggleEvent","$modelValue","$$rAF","$setViewValue","toggleClass","$apply","hasClass","value","nodeName","self","startCollapsed","allowMultiple","$targets","activeIndexes","$active","length","index","indexOf","activeItems","splice","activateItem","$options","$collapse","$viewChangeListeners","$registerToggle","copy","$toggles","$attrs","$unregisterToggle","$unregisterTarget","deactivateItem","fn","fixActiveItemIndexes","$setActive","disallowToggle","$activeIndexes","bsCollapseCtrl","controllers","$animate","ngModelCtrl","attrs","isArray","bsCollapseToggle","$registerTarget","render","active","action","delay","useNative","dateType","dateFormat","timezone","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","autoclose","minDate","Infinity","maxDate","startView","minView","startWeek","daysOfWeekDisabled","iconLeft","iconRight","isNative","DatepickerFactory","parentScope","$datepicker","pickerViews","views","el","selected","date","focus","viewDate","$iconLeft","$iconRight","$picker","$views","$mode","datepickerViews","$selectPane","$toggleMode","setMode","select","isDate","$build","updateDisabledDates","disabledDateRanges","dateRanges","$date","$dateValue","keep","Date","year","getFullYear","month","getDate","mode","pristine","call","$updateSelected","rows","built","$isSelected","$setDisabledEl","disabled","isDisabled","steps","targetDate","getUTCFullYear","getUTCMonth","UTC","$onMouseDown","evt","preventDefault","stopPropagation","isTouch","getUTCDate","$onKeyDown","keyCode","shiftKey","altKey","updateSelected","onKeyDown","$digest","prop","focusElement","_init","_destroy","_show","_hide","blur","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","isMaxValid","isValid","isMinValid","isNaN","parsedDate","getTime","$parsers","unshift","$setValidity","getDateFormattedString","formatDate","isString","lang","format","$dateFormatter","dateParser","$dateParser","strict","validateAgainstMinMaxDate","getDateForAttribute","disabledDates","parse","timezoneOffsetAdjust","isUndefined","NaN","daySplit","arr","mod","n","m","arrays","size","$sce","weekDaysMin","weekdaysShort","weekDaysLabelsHtml","startDate","picker","weekDaysLabels","slice","concat","split","getMonth","update","firstDayOfMonth","firstDate","today","firstDateOffset","build","day","days","isToday","toDateString","label","muted","showLabels","labels","time","isSelected","getDay","newDate","name","firstMonth","months","lastDate","actualMonth","parseInt","firstYear","years","actualYear","setYear","placement","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","$rootScope","$new","parentEl","$isShown","removeClass","prototype","bsDropdown","dropdown","bsShow","getDefaultLocale","id","splitTimeFormat","timeFormat","exec","DATETIME_FORMATS","$locale","getDatetimeFormat","SHORTDAY","hoursFormat","minutesFormat","timeSeparator","ParseDate","seconds","milliseconds","hours","array","isNumeric","parseFloat","isFinite","indexOfCaseInsensitive","len","str","toString","toLowerCase","DateParserFactory","minutes","getHours","getMilliseconds","getMinutes","proto","noop","toDate","regExpMap","sss","dateFilter","mm","keys","setFnMap","map","clonedFormat","search","v","sortedMap","regExpForFormat","re","join","text","replace","Object","escapeReservedSymbols","RegExp","regex","HH","H","hh","h","a","EEEE","EEE","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","setSeconds","s","setMinutes","setHours","setDate","setMonth","setFullYear","$format","baseDate","setMap","formatRegex","formatSetMap","setMapForFormat","matches","fromDate","substr","getTimeForAttribute","daylightSavingAdjust","undo","func","timeout","context","factory","immediate","apply","args","cancel","callNow","leading","trailing","wait","currentStyle","getComputedStyle","extra","boxRect","getBoundingClientRect","left","docElement","ownerDocument","curPosition","curLeft","curCSSTop","documentElement","clientTop","pageXOffset","scrollLeft","clientLeft","curCSSLeft","calculatePosition","curTop","curOffset","curElem","props","isFunction","using","offsetParentRect","offsetParentElement","outer","$parseOptions","$values","regexp","$match","displayFn","locals","valueName","valueFn","ParseOptionsFactory","groupByFn","valuesFn","$parse","keyName","cancelAnimationFrame","when","values","parseValues","raf","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","timer","prefixEvent","template","trim","bodyElement","htmlReplaceRegExp","ModalFactory","enterAnimateCallback","promise","modalElement","leaveAnimateCallback","currentTarget","safeDigest","preventEventDefault","$hide","$$postDigest","$id","$show","$promise","templateEl","fetchTemplate","outerHTML","then","modalLinker","backdropElement","right","z-index","data","$compile","remove","$destroy","after","isElement","$emit","defaultPrevented","display","enter","hideOnBackdropClick","$onKeyUp","leave","which","fetchPromises","cache","$templateCache","res","$http","get","falseValueRegExp","bsModal","modal","routeAttr","$navbar","liElements","li","liElement","pattern","path","autoClose","$popover","PopoverFactory","$tooltip","popover","$applyPlacement","bsPopover","isObject","setViewport","viewport","spies","$document","debounce","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","$trackedElements","sortedElements","activeTarget","debouncedCheckPosition","viewportHeight","throttledCheckPosition","debouncedCheckOffsets","checkOffsets","docEl","$activateElement","source","$getTrackedElement","filter","targetElement","querySelector","trackedElement","b","trackElement","toDelete","untrackElement","activate","scrollspy","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$select","$activeIndex","$showAllNoneButtons","$iconCheckmark","$allText","$noneText","$activate","$isActive","$isVisible","$selectNone","$matches","$updateActiveIndex","$getIndex","minLength","$viewValue","l","inputEl","watchedOptions","parsedOptions","bsOptions","$isEmpty","navClass","$activeClass","$panes","$activePaneChangeListeners","$push","pane","$remove","activeIndex","$tab","transclude","templateUrl","postLink","bsTabsCtrl","warn","console","bsActivePane","parsedBsActivePane","assign","timeType","modelTimeFormat","minTime","maxTime","hourStep","minuteStep","roundDisplay","iconUp","iconDown","arrowBehavior","timepickerFactory","hour","meridian","coeff","createSelection","setSelectionRange","start","selRange","collapse","selectionStart","moveStart","selectionEnd","end","moveEnd","$timepicker","floorMinutes","floor","selectedIndex","defaultDate","second","getSeconds","millisecond","$iconUp","$iconDown","$moveIndex","$switchMeridian","switchMeridian","minute","midIndex","$isBuilt","showAM","isAM","$isDisabled","selectedTime","$arrowAction","$setTimeByStep","hoursLength","triggerHandler","lateralMove","count","selectRange","minutesLength","createTextRange","parsedTime","getTimeFormattedString","timepicker","validateAgainstMinMaxTime","bsEnabled","selector","padding","String","$body","_tipToHide","tipElement","triggers","unbindTriggerEvents","bindKeyboardEvents","$onFocusElementMouseDown","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","rect","elRect","p","scroll","isBody","getCalculatedOffset","actualWidth","actualHeight","outerDims","clientWidth","innerHeight","tip","marginTop","marginLeft","Math","round","delta","getViewportAdjustedDelta","isVertical","replaceArrow","arrowDelta","arrowOffsetPosition","viewportPadding","topEdgeOffset","$viewport","viewportDimensions","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","clearTimeout","tipScope","$$phase","$setEnabled","setEnabled","isEnabled","contentEl","tipLinker","tipTemplate","isNumber","tipContainer","bindTriggerEvents","destroyTipElement","hoverState","lastChild","visibility","prepend","_blur","elementPosition","autoPlace","originalPlacement","containerPosition","tipHeight","tipPosition","applyPlacement","tipWidth","TooltipFactory","$location","tooltip","bsTooltip","limit","autoSelect","comparator","$typeahead","$resetMatches","TypeaheadFactory","typeahead","watchOptions","selectMode","isVisible","displayValue","val"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\n'use strict';\n\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n\n// Source: affix/affix.js\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n\n// Source: alert/alert.js\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      template: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if(options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if(options.duration) {\n          $alert.show = function() {\n            show();\n            $timeout(function() {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function($window, $sce, $alert) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAlert && scope.$watch(attr.bsAlert, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: aside/aside.js\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      template: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function($window, $sce, $aside) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAside && scope.$watch(attr.bsAside, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: button/button.js\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function() {\n\n    var defaults = this.defaults = {\n      activeClass:'active',\n      toggleEvent:'click'\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if(constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if(constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if(hasExoticValues) {\n          controller.$parsers.push(function(viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function(modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n             return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function(newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if(!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if(!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function(child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function(v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: collapse/collapse.js\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function(element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function(element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function(element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function(element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function(value) {\n        if(angular.isArray(value)) {\n          self.$targets.$active = angular.copy(value);\n        }\n        else if(!self.$options.disallowToggle) {\n          // toogle element active status\n          isActive(value) ? deactivateItem(value) : activateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function() {\n        return self.$options.allowMultiple ? self.$targets.$active :\n          self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for(var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function() {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function($window, $animate, $collapse) {\n\n    var defaults = $collapse.defaults;\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            }\n            else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              }\n              else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function() {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function() {\n          var index = attrs.bsCollapseToggle || bsCollapseCtrl.$toggles.indexOf(element);\n          bsCollapseCtrl.$setActive(index * 1);\n          scope.$apply();\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if(bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          }\n          else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: datepicker/datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      template: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if(options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function(date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function(value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function() {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function(date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function(dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function(date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if(!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if(!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if(options.autoclose && !keep) {\n              $timeout(function() { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function(mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function(pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if(pristine === true && $picker.built) return;\n          if(pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function() {\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function(date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function(el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function(value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if(evt.keyCode === 13) {\n            if(!scope.$mode) {\n              return $datepicker.hide(true);\n            } else {\n              return scope.$apply(function() { $datepicker.setMode(scope.$mode - 1); });\n            }\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // if $datepicker is no longer showing, don't setup events\n            if(!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function(blur) {\n          if(!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    var defaults = $datepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!datepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          newValue === true ? datepicker.show() : datepicker.hide();\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if(isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            // console.warn('attr.$observe(%s)=%o', key, newValue);\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            // Build only if dirty\n            !isNaN(datepicker.$options[key]) && datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxDate(parsedDate);\n          }\n\n          if(options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.dateType === 'number') {\n            return date.getTime();\n          } else if(options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.dateType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if(options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function() {\n\n    var defaults = this.defaults = {\n      dayFormat: 'dd',\n      daySplit: 7\n    };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while(arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function($dateFormatter, $dateParser, $sce) {\n\n      return function(picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n            format: options.dayFormat,\n            split: 7,\n            steps: { month: 1 },\n            update: function(date, force) {\n              if(!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getDate() !== viewDate.date) {\n                viewDate.date = picker.$date.getDate();\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1), firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n              var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5), firstDateOffset = firstDate.getTimezoneOffset();\n              var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n              if(firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n              var days = [], day;\n              for(var i = 0; i < 42; i++) { // < 7 * 6\n                day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n                days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n              }\n              scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n              scope.showLabels = true;\n              scope.labels = weekDaysLabelsHtml;\n              scope.rows = split(days, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n            },\n            isDisabled: function(date) {\n              var time = date.getTime();\n\n              // Disabled because of min/max date.\n              if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n              if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n              if (options.disabledDateRanges) {\n                for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                  if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualTime = picker.$date.getTime();\n              var newDate;\n\n              if(evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if(evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if(evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if(evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'month',\n            format: options.monthFormat,\n            split: 4,\n            steps: { year: 1 },\n            update: function(date, force) {\n              if(!this.built || date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstMonth = new Date(viewDate.year, 0, 1);\n              var months = [], month;\n              for (var i = 0; i < 12; i++) {\n                month = new Date(viewDate.year, i, 1);\n                months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n              }\n              scope.title = formatDate(month, options.yearTitleFormat);\n              scope.showLabels = false;\n              scope.rows = split(months, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualMonth = picker.$date.getMonth();\n              var newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if(evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if(evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if(evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'year',\n            format: options.yearFormat,\n            split: 4,\n            steps: { year: 12 },\n            update: function(date, force) {\n              if(!this.built || force || parseInt(date.getFullYear()/20, 10) !== parseInt(viewDate.year/20, 10)) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n              var years = [], year;\n              for (var i = 0; i < 12; i++) {\n                year = new Date(firstYear + i, 0, 1);\n                years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n              }\n              scope.title = years[0].label + '-' + years[years.length - 1].label;\n              scope.showLabels = false;\n              scope.rows = split(years, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualYear = picker.$date.getFullYear(),\n                  newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if(evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if(evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if(evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n\n// Source: dropdown/dropdown.js\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      template: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var scope = $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function(evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if(!items.length) return;\n          var index;\n          angular.forEach(items, function(el, i) {\n            if(matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if(evt.keyCode === 38 && index > 0) index--;\n          else if(evt.keyCode === 40 && index < items.length - 1) index++;\n          else if(angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            options.keyboard && $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          parentEl.hasClass('dropdown') && parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function() {\n          if(!$dropdown.$isShown) return;\n          options.keyboard && $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          parentEl.hasClass('dropdown') && parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function() {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if(evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as an object\n        attr.bsDropdown && scope.$watch(attr.bsDropdown, function(newValue, oldValue) {\n          scope.content = newValue;\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!dropdown || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n          newValue === true ? dropdown.show() : dropdown.hide();\n        });\n\n        // Initialize dropdown\n        var dropdown = $dropdown(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (dropdown) dropdown.destroy();\n          options = null;\n          dropdown = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: helpers/date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function() {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function(format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function(lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[3];\n    };\n\n    this.formatDate = function(date, format, lang, timezone){\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n\n// Source: helpers/date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : proto.setFullYear\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format, timezone) {\n        // check for date format special names\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function(date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n\n// Source: helpers/debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function($timeout) {\n  return function(func, wait, immediate) {\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments,\n        callNow = immediate && !timeout;\n      if(timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if(!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if(callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function($timeout) {\n  return function(func, wait, options) {\n    var timeout = null;\n    options || (options = {});\n    return function() {\n      var context = this,\n        args = arguments;\n      if(!timeout) {\n        if(options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if(options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n// Source: helpers/dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n  \n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = fn.css(element, 'position'),\n          curElem = angular.element(element),\n          props = {};\n      \n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n      \n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && \n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n      \n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      \n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n      \n      if (options.top !== null ) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if ( options.left !== null ) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n\n// Source: helpers/parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function() {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match, displayFn, valueName, keyName, groupByFn, valueFn, valuesFn;\n\n        $parseOptions.init = function() {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]),\n          valueName = match[4] || match[6],\n          keyName = match[5],\n          groupByFn = $parse(match[3] || ''),\n          valueFn = $parse(match[2] ? match[1] : valueName),\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function(scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function(values) {\n            $parseOptions.$values = values ? parseValues(values, scope) : {};\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function(modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function(match, index) {\n            var locals = {}, label, value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n\n// Source: helpers/raf.js\n(angular.version.minor < 3 && angular.version.dot < 14) && angular.module('ng')\n\n.factory('$$rAF', function($window, $timeout) {\n\n  var requestAnimationFrame = $window.requestAnimationFrame ||\n                              $window.webkitRequestAnimationFrame ||\n                              $window.mozRequestAnimationFrame;\n\n  var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                             $window.webkitCancelAnimationFrame ||\n                             $window.mozCancelAnimationFrame ||\n                             $window.webkitCancelRequestAnimationFrame;\n\n  var rafSupported = !!requestAnimationFrame;\n  var raf = rafSupported ?\n    function(fn) {\n      var id = requestAnimationFrame(fn);\n      return function() {\n        cancelAnimationFrame(id);\n      };\n    } :\n    function(fn) {\n      var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n      return function() {\n        $timeout.cancel(timer);\n      };\n    };\n\n  raf.supported = rafSupported;\n\n  return raf;\n\n});\n\n// .factory('$$animateReflow', function($$rAF, $document) {\n\n//   var bodyEl = $document[0].body;\n\n//   return function(fn) {\n//     //the returned function acts as the cancellation function\n//     return $$rAF(function() {\n//       //the line below will force the browser to perform a repaint\n//       //so that all the animated elements within the animation frame\n//       //will be properly updated and drawn on screen. This is\n//       //required to perform multi-class CSS based animations with\n//       //Firefox. DO NOT REMOVE THIS LINE.\n//       var a = bodyEl.offsetWidth + 1;\n//       fn();\n//     });\n//   };\n\n// });\n\n// Source: modal/modal.js\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      template: 'modal/modal.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var trim = String.prototype.trim;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        $modal.$promise = fetchTemplate(options.template);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function(key) {\n          if(options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $modal.$promise = $modal.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]).removeAttr('ng-bind').html(contentTemplate);\n              // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n              if(!config.template) contentEl.next().remove();\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize modal\n        var modalLinker, modalElement;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position:'fixed', top:'0px', left:'0px', bottom:'0px', right:'0px', 'z-index': 1038});\n        $modal.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          modalLinker = $compile(template);\n          $modal.init();\n        });\n\n        $modal.init = function() {\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function() {\n\n          // Remove element\n          if(modalElement) {\n            modalElement.remove();\n            modalElement = null;\n          }\n          if(backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $modal.show = function() {\n          if($modal.$isShown) return;\n\n          var parent, after;\n          if(angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // Fetch a cloned element linked from template\n          modalElement = $modal.$element = modalLinker(scope, function(clonedElement, scope) {});\n\n          if(scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: animation\n          if(options.animation) {\n            if(options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if(options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          if(options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function() {\n          if(!$modal.$isShown) return;\n\n          if(scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          var promise = $animate.leave(modalElement, leaveAnimateCallback);\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          if(options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function() {\n\n          $modal.$isShown ? $modal.hide() : $modal.show();\n\n        };\n\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function(evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        // Private methods\n\n        function hideOnBackdropClick(evt) {\n          if(evt.target !== evt.currentTarget) return;\n          options.backdrop === 'static' ? $modal.focus() : $modal.hide();\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'animation', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['keyboard', 'html'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        if(angular.isDefined(attr.backdrop)) {\n          options.backdrop = falseValueRegExp.test(attr.backdrop) ? false : attr.backdrop;\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsModal && scope.$watch(attr.bsModal, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: navbar/navbar.js\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function() {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function() {\n\n          return $location.path();\n\n        }, function(newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function(li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if(options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if(regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: popover/popover.js\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      container: false,\n      target: false,\n      placement: 'right',\n      template: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if(options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'customClass', 'autoClose', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && requestAnimationFrame(function() {\n              popover && popover.$applyPlacement();\n            });\n          });\n        });\n\n        // Support scope as an object\n        attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n          angular.isDefined(oldValue) && requestAnimationFrame(function() {\n            popover && popover.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n          newValue === true ? popover.show() : popover.hide();\n        });\n        \n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          popover.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: scrollspy/scrollspy.js\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function() {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if(!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if(spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded, unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        var viewportHeight;\n        var scrollTop;\n\n        $scrollspy.init = function() {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if(scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function() {\n\n          // Check internal ref counter\n          this.$$count--;\n          if(this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function() {\n\n          // Not ready yet\n          if(!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if(scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if(angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if(activeTarget === sortedElements[i].target) continue;\n            if(scrollTop < sortedElements[i].offsetTop) continue;\n            if(sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function() {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function(element) {\n          if(activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if(activeElement) {\n              activeElement.source.removeClass('active');\n              if(nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if(nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function(target) {\n          return trackedElements.filter(function(obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function() {\n\n          angular.forEach(trackedElements, function(trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if(options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function(el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function(a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function(target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function(target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if(trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements = trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function(i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function() {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n\n// Source: select/select.js\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      template: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function($window, $document, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        // parse sort option value to support attribute as string\n        // when binded to interpolated value\n        options.sort = options.sort.toString().match(/true|1/i);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        scope.$activeIndex = -1;\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function(index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function(matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function(index) {\n          if(options.multiple) {\n            $select.$isActive(index) ? scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1) : scope.$activeIndex.push(index);\n            if(options.sort) scope.$activeIndex.sort();\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function(index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function() {\n            $select.activate(index);\n            if(options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function(index) {\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function() {\n          if(controller.$modelValue && scope.$matches.length) {\n            if(options.multiple && angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function(value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            }\n          } else if(scope.$activeIndex >= scope.$matches.length) {\n            scope.$activeIndex = options.multiple ? [] : 0;\n          }\n        };\n\n        $select.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function(index) {\n          if(options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          } else {\n            return scope.$activeIndex === index;\n          }\n        };\n\n        $select.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $select.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function(evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if(!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if(evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function() {\n          _show();\n          if(options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function() {\n          if(!options.multiple && !controller.$modelValue) {\n            scope.$activeIndex = -1;\n          } \n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'placeholder', 'multiple', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Add support for select markup\n        if(element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected, index;\n          if(options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function(value) {\n              index = select.$getIndex(value);\n              return angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if(selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if(options.multiple){\n          controller.$isEmpty = function(value){\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tab/tab.js\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // DEPRECATED: $viewChangeListeners, please use $activePaneChangeListeners\n      // Because we deprecated ngModel usage, we rename viewChangeListeners to \n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function(pane) {\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function(pane) {\n        var index = self.$panes.indexOf(pane);\n        var activeIndex = self.$panes.$active;\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to \n          // decrement the active pane index\n          activeIndex--;\n        }\n        else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        self.$setActive(activeIndex);\n      };\n\n      self.$panes.$active = 0;\n      self.$setActive = $scope.$setActive = function(value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n    };\n\n    this.$get = function() {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function(element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // DEPRECATED: ngModel, please use bsActivePane\n        // 'ngModel' is deprecated bacause if interferes with form validation\n        // and status, so avoid using it here.\n        if(ngModelCtrl) {\n          console.warn('Usage of ngModel is deprecated, please use bsActivePane instead!');\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue * 1);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue * 1);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function(newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Add animation class\n        if(bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function(newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function() {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          var active = bsTabsCtrl.$panes.$active;\n          $animate[index === active ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: timepicker/timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      template: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time)\n        {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {hour: startDate.getHours(), meridian: startDate.getHours() < 12, minute: startDate.getMinutes(), second: startDate.getSeconds(), millisecond: startDate.getMilliseconds()};\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {hour: date.getHours(), minute: date.getMinutes(), second: date.getSeconds(), millisecond: date.getMilliseconds()});\n            $timepicker.$build();\n          } else if(!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if(!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if(!angular.isDate(date)) date = new Date(date);\n          if(index === 0) controller.$dateValue.setHours(date.getHours());\n          else if(index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if(options.autoclose && !keep) {\n            $timeout(function() { $timepicker.hide(true); });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [], hour;\n          for(i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({date: hour, label: formatDate(hour, hoursFormat), selected: $timepicker.$date && $timepicker.$isSelected(hour, 0), disabled: $timepicker.$isDisabled(hour, 0)});\n          }\n          var minutes = [], minute;\n          for(i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({date: minute, label: formatDate(minute, minutesFormat), selected: $timepicker.$date && $timepicker.$isSelected(minute, 1), disabled: $timepicker.$isDisabled(minute, 1)});\n          }\n\n          var rows = [];\n          for(i = 0; i < options.length; i++) {\n            rows.push([hours[i], minutes[i]]);\n          }\n          scope.rows = rows;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if(!$timepicker.$date) return false;\n          else if(index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if(index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if(index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4;\n          } else if(index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value,index);\n          } else {\n            $timepicker.$moveIndex(value,index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          }\n          else {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if(index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute);\n            angular.extend(viewDate, {hour: targetDate.getHours()});\n          } else if(index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep));\n            angular.extend(viewDate, {minute: targetDate.getMinutes()});\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if(evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if(evt.keyCode === 13) return $timepicker.hide(true);\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if(evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if(evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          if(selectedIndex === 0) {\n            if(evt.keyCode === 38) newDate.setHours(hours - parseInt(options.hourStep, 10));\n            else if(evt.keyCode === 40) newDate.setHours(hours + parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if(selectedIndex === 1) {\n            if(evt.keyCode === 38) newDate.setMinutes(minutes - parseInt(options.minuteStep, 10));\n            else if(evt.keyCode === 40) newDate.setMinutes(minutes + parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + 1, hoursLength + 1 + minutesLength];\n          } else if(selectedIndex === 2) {\n            if(!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + 1 + minutesLength + 1, hoursLength + 1 + minutesLength + 3];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, end) {\n          if(element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if(element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if(angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if(!$timepicker.$isShown) return;\n          $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['roundDisplay'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!timepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if(isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({format: options.timeFormat, lang: lang});\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(!isValid) {\n              return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if(options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.timeType === 'number') {\n            return date.getTime();\n          } else if(options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if(options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tooltip/tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px'\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // should not parse target attribute, only data-target\n        if(element.attr('data-target')) {\n          options.target = element.attr('data-target');\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: typeahead/typeahead.js\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      template: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'filter',\n      limit: 6,\n      autoSelect: false,\n      comparator: ''\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function(){\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if(scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0: -1;\n          }\n          \n          // When the placement is not one of the bottom placements, re-calc the positioning\n          // so the results render correctly.\n          if (/^(bottom|bottom-left|bottom-right)$/.test(options.placement)) return;\n          \n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          $timeout($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if(parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if(!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden\n          if($typeahead.$isVisible()) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if(evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if(!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .directive('bsTypeahead', function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Disable browser autocompletion\n        element.attr('autocomplete' ,'off');\n        \n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if(filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if(limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if(options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watch(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          }, true);\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            // Prevent input with no future prospect if selectMode is truthy\n            // @TODO test selectMode\n            if(options.selectMode && !values.length && newValue.length > 0) {\n              controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n              return;\n            }\n            if(values.length > limit) values = values.slice(0, limit);\n            var isVisible = typeahead.$isVisible();\n            isVisible && typeahead.update(values);\n            // Do not re-queue an update if a correct value has been selected\n            if(values.length === 1 && values[0].value === newValue) return;\n            !isVisible && typeahead.update(values);\n            // Queue a new rendering that will leverage collection loading\n            controller.$render();\n          });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n          return displayValue === undefined ? '' : displayValue;\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if(controller.$isEmpty(controller.$viewValue)) return element.val('');\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          element.val(selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '').trim() : '');\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n\n})(window, document);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n","'use strict';\n\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      template: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if(options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if(options.duration) {\n          $alert.show = function() {\n            show();\n            $timeout(function() {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function($window, $sce, $alert) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAlert && scope.$watch(attr.bsAlert, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      template: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function($window, $sce, $aside) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAside && scope.$watch(attr.bsAside, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function() {\n\n    var defaults = this.defaults = {\n      activeClass:'active',\n      toggleEvent:'click'\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if(constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if(constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if(hasExoticValues) {\n          controller.$parsers.push(function(viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function(modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n             return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function(newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if(!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if(!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function(child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function(v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function(element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function(element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function(element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function(element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function(value) {\n        if(angular.isArray(value)) {\n          self.$targets.$active = angular.copy(value);\n        }\n        else if(!self.$options.disallowToggle) {\n          // toogle element active status\n          isActive(value) ? deactivateItem(value) : activateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function() {\n        return self.$options.allowMultiple ? self.$targets.$active :\n          self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for(var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function() {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function($window, $animate, $collapse) {\n\n    var defaults = $collapse.defaults;\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            }\n            else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              }\n              else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function() {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function() {\n          var index = attrs.bsCollapseToggle || bsCollapseCtrl.$toggles.indexOf(element);\n          bsCollapseCtrl.$setActive(index * 1);\n          scope.$apply();\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if(bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          }\n          else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      template: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if(options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function(date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function(value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function() {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function(date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function(dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function(date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if(!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if(!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if(options.autoclose && !keep) {\n              $timeout(function() { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function(mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function(pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if(pristine === true && $picker.built) return;\n          if(pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function() {\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function(date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function(el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function(value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if(evt.keyCode === 13) {\n            if(!scope.$mode) {\n              return $datepicker.hide(true);\n            } else {\n              return scope.$apply(function() { $datepicker.setMode(scope.$mode - 1); });\n            }\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // if $datepicker is no longer showing, don't setup events\n            if(!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function(blur) {\n          if(!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    var defaults = $datepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!datepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          newValue === true ? datepicker.show() : datepicker.hide();\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if(isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            // console.warn('attr.$observe(%s)=%o', key, newValue);\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            // Build only if dirty\n            !isNaN(datepicker.$options[key]) && datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxDate(parsedDate);\n          }\n\n          if(options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.dateType === 'number') {\n            return date.getTime();\n          } else if(options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.dateType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if(options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function() {\n\n    var defaults = this.defaults = {\n      dayFormat: 'dd',\n      daySplit: 7\n    };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while(arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function($dateFormatter, $dateParser, $sce) {\n\n      return function(picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n            format: options.dayFormat,\n            split: 7,\n            steps: { month: 1 },\n            update: function(date, force) {\n              if(!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getDate() !== viewDate.date) {\n                viewDate.date = picker.$date.getDate();\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1), firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n              var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5), firstDateOffset = firstDate.getTimezoneOffset();\n              var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n              if(firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n              var days = [], day;\n              for(var i = 0; i < 42; i++) { // < 7 * 6\n                day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n                days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n              }\n              scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n              scope.showLabels = true;\n              scope.labels = weekDaysLabelsHtml;\n              scope.rows = split(days, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n            },\n            isDisabled: function(date) {\n              var time = date.getTime();\n\n              // Disabled because of min/max date.\n              if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n              if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n              if (options.disabledDateRanges) {\n                for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                  if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualTime = picker.$date.getTime();\n              var newDate;\n\n              if(evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if(evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if(evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if(evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'month',\n            format: options.monthFormat,\n            split: 4,\n            steps: { year: 1 },\n            update: function(date, force) {\n              if(!this.built || date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstMonth = new Date(viewDate.year, 0, 1);\n              var months = [], month;\n              for (var i = 0; i < 12; i++) {\n                month = new Date(viewDate.year, i, 1);\n                months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n              }\n              scope.title = formatDate(month, options.yearTitleFormat);\n              scope.showLabels = false;\n              scope.rows = split(months, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualMonth = picker.$date.getMonth();\n              var newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if(evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if(evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if(evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'year',\n            format: options.yearFormat,\n            split: 4,\n            steps: { year: 12 },\n            update: function(date, force) {\n              if(!this.built || force || parseInt(date.getFullYear()/20, 10) !== parseInt(viewDate.year/20, 10)) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n              var years = [], year;\n              for (var i = 0; i < 12; i++) {\n                year = new Date(firstYear + i, 0, 1);\n                years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n              }\n              scope.title = years[0].label + '-' + years[years.length - 1].label;\n              scope.showLabels = false;\n              scope.rows = split(years, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualYear = picker.$date.getFullYear(),\n                  newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if(evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if(evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if(evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      template: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var scope = $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function(evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if(!items.length) return;\n          var index;\n          angular.forEach(items, function(el, i) {\n            if(matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if(evt.keyCode === 38 && index > 0) index--;\n          else if(evt.keyCode === 40 && index < items.length - 1) index++;\n          else if(angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            options.keyboard && $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          parentEl.hasClass('dropdown') && parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function() {\n          if(!$dropdown.$isShown) return;\n          options.keyboard && $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          parentEl.hasClass('dropdown') && parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function() {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if(evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as an object\n        attr.bsDropdown && scope.$watch(attr.bsDropdown, function(newValue, oldValue) {\n          scope.content = newValue;\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!dropdown || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n          newValue === true ? dropdown.show() : dropdown.hide();\n        });\n\n        // Initialize dropdown\n        var dropdown = $dropdown(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (dropdown) dropdown.destroy();\n          options = null;\n          dropdown = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function() {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function(format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function(lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[3];\n    };\n\n    this.formatDate = function(date, format, lang, timezone){\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : proto.setFullYear\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format, timezone) {\n        // check for date format special names\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function(date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function($timeout) {\n  return function(func, wait, immediate) {\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments,\n        callNow = immediate && !timeout;\n      if(timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if(!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if(callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function($timeout) {\n  return function(func, wait, options) {\n    var timeout = null;\n    options || (options = {});\n    return function() {\n      var context = this,\n        args = arguments;\n      if(!timeout) {\n        if(options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if(options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n  \n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = fn.css(element, 'position'),\n          curElem = angular.element(element),\n          props = {};\n      \n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n      \n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && \n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n      \n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      \n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n      \n      if (options.top !== null ) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if ( options.left !== null ) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function() {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match, displayFn, valueName, keyName, groupByFn, valueFn, valuesFn;\n\n        $parseOptions.init = function() {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]),\n          valueName = match[4] || match[6],\n          keyName = match[5],\n          groupByFn = $parse(match[3] || ''),\n          valueFn = $parse(match[2] ? match[1] : valueName),\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function(scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function(values) {\n            $parseOptions.$values = values ? parseValues(values, scope) : {};\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function(modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function(match, index) {\n            var locals = {}, label, value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\n(angular.version.minor < 3 && angular.version.dot < 14) && angular.module('ng')\n\n.factory('$$rAF', function($window, $timeout) {\n\n  var requestAnimationFrame = $window.requestAnimationFrame ||\n                              $window.webkitRequestAnimationFrame ||\n                              $window.mozRequestAnimationFrame;\n\n  var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                             $window.webkitCancelAnimationFrame ||\n                             $window.mozCancelAnimationFrame ||\n                             $window.webkitCancelRequestAnimationFrame;\n\n  var rafSupported = !!requestAnimationFrame;\n  var raf = rafSupported ?\n    function(fn) {\n      var id = requestAnimationFrame(fn);\n      return function() {\n        cancelAnimationFrame(id);\n      };\n    } :\n    function(fn) {\n      var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n      return function() {\n        $timeout.cancel(timer);\n      };\n    };\n\n  raf.supported = rafSupported;\n\n  return raf;\n\n});\n\n// .factory('$$animateReflow', function($$rAF, $document) {\n\n//   var bodyEl = $document[0].body;\n\n//   return function(fn) {\n//     //the returned function acts as the cancellation function\n//     return $$rAF(function() {\n//       //the line below will force the browser to perform a repaint\n//       //so that all the animated elements within the animation frame\n//       //will be properly updated and drawn on screen. This is\n//       //required to perform multi-class CSS based animations with\n//       //Firefox. DO NOT REMOVE THIS LINE.\n//       var a = bodyEl.offsetWidth + 1;\n//       fn();\n//     });\n//   };\n\n// });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      template: 'modal/modal.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var trim = String.prototype.trim;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        $modal.$promise = fetchTemplate(options.template);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function(key) {\n          if(options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $modal.$promise = $modal.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]).removeAttr('ng-bind').html(contentTemplate);\n              // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n              if(!config.template) contentEl.next().remove();\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize modal\n        var modalLinker, modalElement;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position:'fixed', top:'0px', left:'0px', bottom:'0px', right:'0px', 'z-index': 1038});\n        $modal.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          modalLinker = $compile(template);\n          $modal.init();\n        });\n\n        $modal.init = function() {\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function() {\n\n          // Remove element\n          if(modalElement) {\n            modalElement.remove();\n            modalElement = null;\n          }\n          if(backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $modal.show = function() {\n          if($modal.$isShown) return;\n\n          var parent, after;\n          if(angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // Fetch a cloned element linked from template\n          modalElement = $modal.$element = modalLinker(scope, function(clonedElement, scope) {});\n\n          if(scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: animation\n          if(options.animation) {\n            if(options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if(options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          if(options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function() {\n          if(!$modal.$isShown) return;\n\n          if(scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          var promise = $animate.leave(modalElement, leaveAnimateCallback);\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          if(options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function() {\n\n          $modal.$isShown ? $modal.hide() : $modal.show();\n\n        };\n\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function(evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        // Private methods\n\n        function hideOnBackdropClick(evt) {\n          if(evt.target !== evt.currentTarget) return;\n          options.backdrop === 'static' ? $modal.focus() : $modal.hide();\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'animation', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['keyboard', 'html'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        if(angular.isDefined(attr.backdrop)) {\n          options.backdrop = falseValueRegExp.test(attr.backdrop) ? false : attr.backdrop;\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsModal && scope.$watch(attr.bsModal, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function() {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function() {\n\n          return $location.path();\n\n        }, function(newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function(li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if(options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if(regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      container: false,\n      target: false,\n      placement: 'right',\n      template: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if(options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'customClass', 'autoClose', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && requestAnimationFrame(function() {\n              popover && popover.$applyPlacement();\n            });\n          });\n        });\n\n        // Support scope as an object\n        attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n          angular.isDefined(oldValue) && requestAnimationFrame(function() {\n            popover && popover.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n          newValue === true ? popover.show() : popover.hide();\n        });\n        \n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          popover.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function() {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if(!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if(spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded, unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        var viewportHeight;\n        var scrollTop;\n\n        $scrollspy.init = function() {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if(scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function() {\n\n          // Check internal ref counter\n          this.$$count--;\n          if(this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function() {\n\n          // Not ready yet\n          if(!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if(scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if(angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if(activeTarget === sortedElements[i].target) continue;\n            if(scrollTop < sortedElements[i].offsetTop) continue;\n            if(sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function() {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function(element) {\n          if(activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if(activeElement) {\n              activeElement.source.removeClass('active');\n              if(nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if(nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function(target) {\n          return trackedElements.filter(function(obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function() {\n\n          angular.forEach(trackedElements, function(trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if(options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function(el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function(a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function(target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function(target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if(trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements = trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function(i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function() {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      template: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function($window, $document, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        // parse sort option value to support attribute as string\n        // when binded to interpolated value\n        options.sort = options.sort.toString().match(/true|1/i);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        scope.$activeIndex = -1;\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function(index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function(matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function(index) {\n          if(options.multiple) {\n            $select.$isActive(index) ? scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1) : scope.$activeIndex.push(index);\n            if(options.sort) scope.$activeIndex.sort();\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function(index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function() {\n            $select.activate(index);\n            if(options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function(index) {\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function() {\n          if(controller.$modelValue && scope.$matches.length) {\n            if(options.multiple && angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function(value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            }\n          } else if(scope.$activeIndex >= scope.$matches.length) {\n            scope.$activeIndex = options.multiple ? [] : 0;\n          }\n        };\n\n        $select.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function(index) {\n          if(options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          } else {\n            return scope.$activeIndex === index;\n          }\n        };\n\n        $select.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $select.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function(evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if(!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if(evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function() {\n          _show();\n          if(options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function() {\n          if(!options.multiple && !controller.$modelValue) {\n            scope.$activeIndex = -1;\n          } \n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'placeholder', 'multiple', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Add support for select markup\n        if(element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected, index;\n          if(options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function(value) {\n              index = select.$getIndex(value);\n              return angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if(selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if(options.multiple){\n          controller.$isEmpty = function(value){\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // DEPRECATED: $viewChangeListeners, please use $activePaneChangeListeners\n      // Because we deprecated ngModel usage, we rename viewChangeListeners to \n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function(pane) {\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function(pane) {\n        var index = self.$panes.indexOf(pane);\n        var activeIndex = self.$panes.$active;\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to \n          // decrement the active pane index\n          activeIndex--;\n        }\n        else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        self.$setActive(activeIndex);\n      };\n\n      self.$panes.$active = 0;\n      self.$setActive = $scope.$setActive = function(value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n    };\n\n    this.$get = function() {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function(element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // DEPRECATED: ngModel, please use bsActivePane\n        // 'ngModel' is deprecated bacause if interferes with form validation\n        // and status, so avoid using it here.\n        if(ngModelCtrl) {\n          console.warn('Usage of ngModel is deprecated, please use bsActivePane instead!');\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue * 1);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue * 1);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function(newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Add animation class\n        if(bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function(newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function() {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          var active = bsTabsCtrl.$panes.$active;\n          $animate[index === active ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      template: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time)\n        {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {hour: startDate.getHours(), meridian: startDate.getHours() < 12, minute: startDate.getMinutes(), second: startDate.getSeconds(), millisecond: startDate.getMilliseconds()};\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {hour: date.getHours(), minute: date.getMinutes(), second: date.getSeconds(), millisecond: date.getMilliseconds()});\n            $timepicker.$build();\n          } else if(!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if(!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if(!angular.isDate(date)) date = new Date(date);\n          if(index === 0) controller.$dateValue.setHours(date.getHours());\n          else if(index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if(options.autoclose && !keep) {\n            $timeout(function() { $timepicker.hide(true); });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [], hour;\n          for(i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({date: hour, label: formatDate(hour, hoursFormat), selected: $timepicker.$date && $timepicker.$isSelected(hour, 0), disabled: $timepicker.$isDisabled(hour, 0)});\n          }\n          var minutes = [], minute;\n          for(i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({date: minute, label: formatDate(minute, minutesFormat), selected: $timepicker.$date && $timepicker.$isSelected(minute, 1), disabled: $timepicker.$isDisabled(minute, 1)});\n          }\n\n          var rows = [];\n          for(i = 0; i < options.length; i++) {\n            rows.push([hours[i], minutes[i]]);\n          }\n          scope.rows = rows;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if(!$timepicker.$date) return false;\n          else if(index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if(index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if(index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4;\n          } else if(index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value,index);\n          } else {\n            $timepicker.$moveIndex(value,index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          }\n          else {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if(index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute);\n            angular.extend(viewDate, {hour: targetDate.getHours()});\n          } else if(index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep));\n            angular.extend(viewDate, {minute: targetDate.getMinutes()});\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if(evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if(evt.keyCode === 13) return $timepicker.hide(true);\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if(evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if(evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          if(selectedIndex === 0) {\n            if(evt.keyCode === 38) newDate.setHours(hours - parseInt(options.hourStep, 10));\n            else if(evt.keyCode === 40) newDate.setHours(hours + parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if(selectedIndex === 1) {\n            if(evt.keyCode === 38) newDate.setMinutes(minutes - parseInt(options.minuteStep, 10));\n            else if(evt.keyCode === 40) newDate.setMinutes(minutes + parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + 1, hoursLength + 1 + minutesLength];\n          } else if(selectedIndex === 2) {\n            if(!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + 1 + minutesLength + 1, hoursLength + 1 + minutesLength + 3];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, end) {\n          if(element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if(element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if(angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if(!$timepicker.$isShown) return;\n          $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['roundDisplay'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!timepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if(isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({format: options.timeFormat, lang: lang});\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(!isValid) {\n              return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if(options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.timeType === 'number') {\n            return date.getTime();\n          } else if(options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if(options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px'\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // should not parse target attribute, only data-target\n        if(element.attr('data-target')) {\n          options.target = element.attr('data-target');\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      template: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'filter',\n      limit: 6,\n      autoSelect: false,\n      comparator: ''\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function(){\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if(scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0: -1;\n          }\n          \n          // When the placement is not one of the bottom placements, re-calc the positioning\n          // so the results render correctly.\n          if (/^(bottom|bottom-left|bottom-right)$/.test(options.placement)) return;\n          \n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          $timeout($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if(parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if(!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden\n          if($typeahead.$isVisible()) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if(evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if(!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .directive('bsTypeahead', function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Disable browser autocompletion\n        element.attr('autocomplete' ,'off');\n        \n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if(filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if(limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if(options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watch(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          }, true);\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            // Prevent input with no future prospect if selectMode is truthy\n            // @TODO test selectMode\n            if(options.selectMode && !values.length && newValue.length > 0) {\n              controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n              return;\n            }\n            if(values.length > limit) values = values.slice(0, limit);\n            var isVisible = typeahead.$isVisible();\n            isVisible && typeahead.update(values);\n            // Do not re-queue an update if a correct value has been selected\n            if(values.length === 1 && values[0].value === newValue) return;\n            !isVisible && typeahead.update(values);\n            // Queue a new rendering that will leverage collection loading\n            controller.$render();\n          });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n          return displayValue === undefined ? '' : displayValue;\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if(controller.$isEmpty(controller.$viewValue)) return element.val('');\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          element.val(selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '').trim() : '');\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}